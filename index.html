<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
      <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <meta name="apple-mobile-web-app-capable" content="none" />
      <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
      <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height" />
    <title>Canvas Pattern 240x160 (WebGL2)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body style="margin: 0px; background-color: black;">
    <canvas id="canvas-1"></canvas>
    <canvas id="canvas" hidden></canvas>
    <label for="" style="color: wheat;">(WebGL2)</label>
    <input type = "file" id = "file-input">
    <script type="module">
      import mGBA_v2 from "./temp/mgba.js";
      const Module = {
        canvas: document.getElementById("canvas")
      };

      function initializeCore(coreInitFunction, module) {
        coreInitFunction(module).then(module => module.FSInit());
      }
      initializeCore(mGBA_v2, Module);
          document.getElementById("file-input").addEventListener("change", function(event) {
            const file = event.target.files[0];
            if (!file) return;
            Module.uploadRom(file, () => {
              Module.FSSync();
              Module.loadGame(`/data/games/${file.name}`);
              setTimeout(() => {
                runG("GBC");
              }, 1000);
            });
          });
          function runG(systemType) {
            const width = systemType === "GBC" ? 160 : 240;
            const height = systemType === "GBC" ? 144 : 160;
            const stride = systemType === "GBC" ? 256 : 240;
            const bufferCanvas = document.getElementById("canvas-1");
            const aspectRatio = 144 / 160;
            const upscaleFactor = 2;
            bufferCanvas.width = window.innerWidth * upscaleFactor;
            bufferCanvas.height = bufferCanvas.width * aspectRatio
            //bufferCanvas.style.imageRendering = "pixelated";
            bufferCanvas.style.transform = `scale(${1/upscaleFactor})`;
            bufferCanvas.style.transformOrigin = "top left";
            const gl = bufferCanvas.getContext("webgl2");
            if (!gl) {
              console.error("WebGL2 not supported");
              return;
            }
            // Vertex Shader (WebGL2)
            const vertexShaderSource = `#version 300 es
            in vec2 position;
            in vec2 texcoord;
            out vec2 v_texcoord;
            void main() {
                gl_Position = vec4(position, 0, 1);
                v_texcoord = texcoord;
            }
            `;
            // Fragment Shader (WebGL2) với nội suy sắc nét
            const fragmentShaderSource = `#version 300 es
            precision highp float;

            in vec2 v_texcoord;
            out vec4 fragColor;

            uniform sampler2D texSampler;
            uniform vec2 emu_lcd_size;
            uniform vec2 render_size;
            uniform float smooth_width;
            uniform float smooth_height;

            void main() {
                vec2 ip = floor(v_texcoord * emu_lcd_size - 0.5) + 0.5;
                vec2 residual = fract(v_texcoord * emu_lcd_size + 0.5);
                ip /= emu_lcd_size;

                vec4 v0 = texture(texSampler, ip);
                vec4 v1 = texture(texSampler, ip + vec2(1.0, 0.0) / emu_lcd_size);
                vec4 v2 = texture(texSampler, ip + vec2(0.0, 1.0) / emu_lcd_size);
                vec4 v3 = texture(texSampler, ip + vec2(1.0, 1.0) / emu_lcd_size);

                vec2 smooth_dim = vec2(smooth_width, smooth_height);
                if (fract(render_size.x / emu_lcd_size.x) * emu_lcd_size.x < 0.01) smooth_dim.x = 0.01;
                if (fract(render_size.y / emu_lcd_size.y) * emu_lcd_size.y < 0.01) smooth_dim.y = 0.01;

                vec2 alpha = vec2(
                    smoothstep(0.5 - smooth_dim.x * 0.5, 0.5 + smooth_dim.x * 0.5, residual.x),
                    smoothstep(0.5 - smooth_dim.y * 0.5, 0.5 + smooth_dim.y * 0.5, residual.y)
                );

                fragColor = mix(mix(v0, v1, alpha.x), mix(v2, v3, alpha.x), alpha.y);
            }`;

            function createShader(gl, type, source) {
              const shader = gl.createShader(type);
              gl.shaderSource(shader, source);
              gl.compileShader(shader);
              if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
              }
              return shader;
            }
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
              console.error(gl.getProgramInfoLog(program));
              return;
            }
            gl.useProgram(program);
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            // Uniforms
            gl.uniform2f(gl.getUniformLocation(program, "emu_lcd_size"), 160, 144);
            gl.uniform2f(gl.getUniformLocation(program, "render_size"), bufferCanvas.width, bufferCanvas.height);
            gl.uniform1f(gl.getUniformLocation(program, "smooth_width"), 160 / bufferCanvas.width);
            gl.uniform1f(gl.getUniformLocation(program, "smooth_height"), 144 / bufferCanvas.height);
            // Vertex Data
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1, ]), gl.STATIC_DRAW);
            const positionLocation = gl.getAttribLocation(program, "position");
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            const texcoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
              0, 1, 1, 1, 0, 0, 1, 0,
            ]), gl.STATIC_DRAW);
            const texcoordLocation = gl.getAttribLocation(program, "texcoord");
            gl.enableVertexAttribArray(texcoordLocation);
            gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);

            function updateFrame() {
              const pixelData = Module.getPixelData();
              if (!pixelData) return;
              const imageData = new Uint8Array(width * height * 4);
              for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                  const srcIndex = y * stride + x;
                  const destIndex = (y * width + x) * 4;
                  const color = pixelData[srcIndex];
                  imageData[destIndex] = (color & 0xFF);
                  imageData[destIndex + 1] = (color >> 8) & 0xFF;
                  imageData[destIndex + 2] = (color >> 16) & 0xFF;
                  imageData[destIndex + 3] = 255;
                }
              }
              // Upload texture lên WebGL
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
              // Vẽ lại
              gl.clear(gl.COLOR_BUFFER_BIT);
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
              requestAnimationFrame(() => updateFrame());
            }
            updateFrame();
          }
    </script>
  </body>
</html>