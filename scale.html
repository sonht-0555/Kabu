<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="apple-mobile-web-app-capable" content="none" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height" />
    <title>mGBA Scale</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      .shader {
        opacity: 0.3;
        position: absolute;
        top: 0;
        pointer-events: none;
        shape-rendering: crispEdges;
        image-rendering: pixelated;
        image-rendering: -webkit-optimize-contrast;
        text-rendering: geometricPrecision;
        background: url("data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 1H1V15H15V1ZM0 0V16H16V0H0Z' fill='black'/%3E%3C/svg%3E%0A");
      }
    </style>
  </head>
  <body style="margin: 0px; background-color: black;">
    <div>
      <canvas id="canvas-1"></canvas>
      <div class="shader" id="shader"></div>
    </div>
    <canvas id="canvas" hidden></canvas>
    <label for="" style="color: white">GBC - GBA [4.2]</label>
    </br>
    </br>
    <input type="file" id="file-input" accept="">
    <br>
    <br>
    <button id="toggleShader">Shader</button>
    <button id="integerScaling">Integer Scaling</button>
    <button id="toggleColorAdjustment">Color Adjustment</button>
    <select id="colorCorrectionStrength">
      <option value="1.0">Color Streng - Max</option>
      <option value="0.75">Color Streng - 0.75</option>
      <option value="0.5">Color Streng - 0.5</option>
      <option value="0.25">Color Streng - 0.25</option>
      <option value="0.0">Color Streng - Off</option>
    </select>
    <br>
    <br>
    <script type="module">
      import mGBA_v2 from "./temp/mgba.js";
      const Module = {
        canvas: document.getElementById("canvas")
      };

      function initializeCore(coreInitFunction, module) {
        coreInitFunction(module).then(module => module.FSInit());
      }
      let gl = null;
      let program = null;
      let systemType;
      let integerStatus = false;
      let enableColorAdjustment = 0;
      let colorStreng = 1;
      let upscaleFactor = 3;
      let upscaleShader;
      let gameWidth;
      let gameHeight;
      let gameStride;
      let texture;
      const bufferCanvas = document.getElementById("canvas-1");
      const shaderElement = document.getElementById("shader");
      const vertexShaderSource = `#version 300 es
      in vec2 position;
      in vec2 texcoord;
      out vec2 v_texcoord;
      void main() {
          gl_Position = vec4(position, 0, 1);
          v_texcoord = texcoord;
      }
      `;
      const fragmentShaderSource = `#version 300 es
      precision highp float;
      in vec2 v_texcoord;
      out vec4 fragColor;
      uniform sampler2D texSampler;
      uniform vec2 game_size;
      uniform vec2 render_size;
      uniform float smooth_width;
      uniform float smooth_height;
      uniform float input_gamma;
      uniform float color_correction_strength;
      uniform vec3 red_color;
      uniform vec3 green_color;
      uniform vec3 blue_color;
      uniform bool enable_color_adjustment;

      vec3 adjust_color(vec4 color) {
          vec3 c = pow(color.rgb, vec3(input_gamma));    // Điều chỉnh gamma cho các kênh màu
          c = c.r * red_color + c.g * green_color + c.b * blue_color;  // Trộn với tỷ lệ các màu
          c = pow(c, vec3(1.0 / 2.2));  // Quay lại giá trị gamma bình thường
          return mix(color.rgb, clamp(c, 0., 1.), color_correction_strength); // Trả về màu đã chỉnh
      }

      vec4 get_color(vec2 tex_coord) {
          vec4 color = texture(texSampler, tex_coord);  // Lấy màu từ texture
          if (enable_color_adjustment) {
              color.rgb = adjust_color(color);  // Nếu bật điều chỉnh màu, gọi hàm adjust_color
          }
          return color;  // Trả về màu
      }

      vec4 interpolate_color(vec2 tex_coord) {
          vec2 ip = floor(tex_coord * game_size - 0.5) + 0.5;  // Tính toán tọa độ pixel
          vec2 residual = fract(tex_coord * game_size + 0.5);  // Lấy phần dư của tọa độ
          ip /= game_size;  // Đưa tọa độ về phạm vi [0, 1]
          vec4 v0 = get_color(ip);  // Lấy màu tại pixel (0, 0)
          vec4 v1 = get_color(ip + vec2(1.0, 0.0) / game_size);  // Lấy màu tại pixel (1, 0)
          vec4 v2 = get_color(ip + vec2(0.0, 1.0) / game_size);  // Lấy màu tại pixel (0, 1)
          vec4 v3 = get_color(ip + vec2(1.0, 1.0) / game_size);  // Lấy màu tại pixel (1, 1)

          vec2 smooth_dim = vec2(smooth_width, smooth_height);  // Kích thước làm mượt
          if (fract(render_size.x / game_size.x) * game_size.x < 0.01) smooth_dim.x = 0.01;  // Điều chỉnh nếu cần thiết
          if (fract(render_size.y / game_size.y) * game_size.y < 0.01) smooth_dim.y = 0.01;  // Điều chỉnh nếu cần thiết

          vec2 alpha = vec2(
              smoothstep(0.5 - smooth_dim.x * 0.5, 0.5 + smooth_dim.x * 0.5, residual.x),  // Nội suy cho x
              smoothstep(0.5 - smooth_dim.y * 0.5, 0.5 + smooth_dim.y * 0.5, residual.y)   // Nội suy cho y
          );
          return mix(mix(v0, v1, alpha.x), mix(v2, v3, alpha.x), alpha.y);  // Trả về màu nội suy
      }

      void main() {
          bool shouldInterpolate = fract(render_size.x / game_size.x) > 0.001;
          vec4 color;
          if (shouldInterpolate) {
              color = interpolate_color(v_texcoord);  // Nội suy nếu cần

              // Xác định viền 2 pixel
              vec2 pixel_size = 2.0 / render_size;
              if (v_texcoord.x < pixel_size.x || v_texcoord.x > 1.0 - pixel_size.x ||
                  v_texcoord.y < pixel_size.y || v_texcoord.y > 1.0 - pixel_size.y) {
                  color.rgb = vec3(0.8667, 0.3373, 0.2235); // Màu #DD5639
              }

          } else {
              color = get_color(v_texcoord);  // Lấy màu trực tiếp nếu không nội suy
          }

          fragColor = color;  // Trả về màu cuối cùng
      }`;

      function createShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      function setupStyle() {
        const clientWidth = document.documentElement.clientWidth;
        const dpr = window.devicePixelRatio;
        const integerScaling = Math.floor((clientWidth * dpr) / gameWidth);
        if (systemType === "gbc") {
          gameWidth = 160;
          gameHeight = 144;
          gameStride = 256;
          upscaleShader = 4;
        } else {
          gameWidth = 240;
          gameHeight = 160;
          gameStride = 240;
          upscaleShader = 2;
        }
        if (integerStatus === true) {
          bufferCanvas.width = gameWidth;
          bufferCanvas.height = gameHeight;
          bufferCanvas.style.zoom = `${integerScaling / dpr}`;
          bufferCanvas.style.imageRendering = "pixelated";
          bufferCanvas.style.imageRendering = "crisp-edges";
          shaderElement.style.transform = `scale(${(integerScaling / dpr) / upscaleShader})`;
        } else {
          bufferCanvas.width = clientWidth * upscaleFactor;
          bufferCanvas.height = clientWidth * upscaleFactor * (gameHeight / gameWidth);
          bufferCanvas.style.zoom = `${1 / upscaleFactor}`;
          bufferCanvas.style.imageRendering = "";
          shaderElement.style.transform = `scale(${(clientWidth / gameWidth) / upscaleShader})`;
        }
        shaderElement.style.width = `${gameWidth * upscaleShader}px`;
        shaderElement.style.height = `${gameHeight * upscaleShader}px`;
        shaderElement.style.backgroundSize = `${upscaleShader}px ${upscaleShader}px`;
        shaderElement.style.transformOrigin = "top left";
      }

      function setupWebGL() {
        gl = bufferCanvas.getContext("webgl2");
        if (!gl) {
          console.error("WebGL2 not supported");
          return null;
        }
        gl.viewport(0, 0, bufferCanvas.width, bufferCanvas.height);
      }

      function setupShaders() {
        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
        program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(program));
          return null;
        }
        gl.useProgram(program);
      }

      function setupTexture() {
        texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.uniform2f(gl.getUniformLocation(program, "game_size"), gameWidth, gameHeight);
        gl.uniform2f(gl.getUniformLocation(program, "render_size"), gl.canvas.width, gl.canvas.height);
        gl.uniform1f(gl.getUniformLocation(program, "smooth_width"), gameWidth / gl.canvas.width);
        gl.uniform1f(gl.getUniformLocation(program, "smooth_height"), gameHeight / gl.canvas.height);
        gl.uniform1f(gl.getUniformLocation(program, "input_gamma"), 2.2);
        gl.uniform3f(gl.getUniformLocation(program, "red_color"), 26. / 32, 0. / 32, 6. / 32);
        gl.uniform3f(gl.getUniformLocation(program, "green_color"), 4. / 32, 24. / 32, 4. / 32);
        gl.uniform3f(gl.getUniformLocation(program, "blue_color"), 2. / 32, 8. / 32, 22. / 32);
      }

      function setupBuffers() {
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1, ]), gl.STATIC_DRAW);
        const positionLocation = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        const texcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          0, 1, 1, 1, 0, 0, 1, 0,
        ]), gl.STATIC_DRAW);
        const texcoordLocation = gl.getAttribLocation(program, "texcoord");
        gl.enableVertexAttribArray(texcoordLocation);
        gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);
      }

      function renderPixel() {
        const pixelData = Module.getPixelData();
        if (!pixelData) return;
        const imageData = new Uint8Array(gameWidth * gameHeight * 4);
        for (let y = 0; y < gameHeight; y++) {
          for (let x = 0; x < gameWidth; x++) {
            const srcIndex = y * gameStride + x;
            const destIndex = (y * gameWidth + x) * 4;
            const color = pixelData[srcIndex];
            imageData[destIndex] = (color & 0xFF);
            imageData[destIndex + 1] = (color >> 8) & 0xFF;
            imageData[destIndex + 2] = (color >> 16) & 0xFF;
            imageData[destIndex + 3] = 255;
          }
        }
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gameWidth, gameHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform1i(gl.getUniformLocation(program, "enable_color_adjustment"), enableColorAdjustment);
        gl.uniform1f(gl.getUniformLocation(program, "color_correction_strength"), colorStreng);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(() => renderPixel(gl, texture, gameWidth, gameHeight, gameStride, program));
      }

      function runG() {
        setupStyle();
        setupWebGL();
        setupShaders();
        setupTexture();
        setupBuffers();
        renderPixel();
      }

      function updateViewport(width, height) {
        gl.viewport(0, 0, width, height);
        gl.useProgram(program);
        gl.uniform2f(gl.getUniformLocation(program, "render_size"), width, height);
      }
      document.addEventListener("DOMContentLoaded", function() {
        initializeCore(mGBA_v2, Module);
        document.getElementById("file-input").addEventListener("change", function(event) {
          const file = event.target.files[0];
          if (!file) return;
          Module.uploadRom(file, () => {
            Module.FSSync();
            Module.loadGame(`/data/games/${file.name}`);
            systemType = file.name.slice(-3)
            console.log("sysType", systemType)
            setTimeout(() => {
              runG();
            }, 1000);
          });
        });
        document.getElementById("toggleColorAdjustment").addEventListener("click", () => {
          enableColorAdjustment = 1 - enableColorAdjustment;
        });
        document.getElementById("toggleShader").addEventListener("click", () => {
          const shader = document.getElementById("shader");
          shader.style.display = (shader.style.display === "none") ? "block" : "none";
        });
        document.getElementById("colorCorrectionStrength").addEventListener("change", (event) => {
          colorStreng = parseFloat(event.target.value);
          gl.useProgram(program);
          gl.uniform1f(gl.getUniformLocation(program, "color_correction_strength"), colorStreng); // Cập nhật giá trị uniform
        });
        document.getElementById("integerScaling").addEventListener("click", () => {
          integerStatus = !integerStatus;
          if (integerStatus) {
            setupStyle();
            updateViewport(gameWidth, gameHeight);
          } else {
            setupStyle();
            updateViewport(bufferCanvas.width, bufferCanvas.height);
          }
          console.log("Integer Scaling:", integerStatus);
        });
        window.addEventListener("resize", () => {
          if (integerStatus === true) {
            setupStyle();
            updateViewport(gameWidth, gameHeight);
          } else {
            setupStyle();
            updateViewport(bufferCanvas.width, bufferCanvas.height);
          }
        });
      })
    </script>
  </body>
</html>